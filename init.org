#+TITLE: init.el for Noah Hoffman
#+AUTHOR: Noah Hoffman

#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STYLE: <link rel="stylesheet" type="text/css" href="./worg.css" />
#+BIND: org-export-html-postamble nil
#+PROPERTY: header-args:elisp :tangle init.el
#+PROPERTY: header-args:sh :eval no :exports code

In a fit of literate programming yak-shaving, I implemented my Emacs
configuration as an org-mode file. I have also tried to a provide
complete-ish description of my environment for anyone interested in
starting more or less from scratch.

- The source for this page is available at https://github.com/nhoffman/.emacs.d
- The html-exported version of this page is hosted at http://nhoffman.github.io/.emacs.d

#+TOC: headlines 1

* Initial setup

You can install this configuration by either cloning it directly from
my repository, of by forking on GitHub and installing yours (obviously
you will want to do the latter if you want to retain your own
modifications:

#+BEGIN_SRC sh
cd ~
git clone https://github.com/nhoffman/.emacs.d.git
#+END_SRC

After cloning the repository into your home directory, just a bit of
setup is required before first use.

** set up a shell environment

This configuration provides some commands (tested with bash and zsh)
that are useful for using Emacs from the shell. In particular, if you
are on a mac and have installed [[http://emacsformacosx.com/][Emacs for OS X]] or compiled the Cocoa
version, Emacs will be installed to
=/Applications/Emacs.app/Contents/MacOS/Emacs= and =emacsclient= is
found in
=/Applications/Emacs.app/Contents/MacOS/bin/emacsclient=. These are
aliased to =emacs= and =emacsclient=, respectively.

In addition, there are some shell commands that simplify running and
using Emacs in server mode:

- edaemon :: launch the Emacs server daemon, removing any locked desktop files.
- ec :: attach to the Emacs server in GUI mode (=emacsclient -c=) in the background.
- enw :: attach to the Emacs server in terminal mode in place (=emacsclient -nw=).
- e :: open a file in an already open window (=emacsclient -n=).

Rather than copying the functions defined in =init.bash= elsewhere,
I'd recommend sourcing it instead. For example, just place the
following in your =~/.bash_login= or =~/.zshrc= or [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][whatever]] (depending
on your shell):

#+BEGIN_SRC sh :eval no
if [[ -f ~/.emacs.d/init.bash ]]; then
    source ~/.emacs.d/init.bash
fi
#+END_SRC

Here's what this file looks like

#+BEGIN_SRC sh :eval yes :exports results
cat init.bash
#+END_SRC

You will have to open a new terminal window for the shell commands
above to become available. Once they are, you can launch the graphical
version of emacs using:

: emacs -c &

or the terminal version using

: emacs -nw

A bit of explanation about Emacs server: the above two commands launch
Emacs in an entirely new process. Using the Emacs server, you can run
an Emacs server instance in the background and then "attach" either a
graphical or terminal window as necessary. Working locally, you would
do this by first starting the server:

: edaemon

And then opening either a graphical or terminal window, for example:

: ec

If you are subsequently working at the command line and you want to
open =somefile= in an already-open Emacs window, you can use:

: e somefile

(You can of course always open a file from within Emacs using many
mechanisms, eg using =C-c f=).

Emacs server is particularly useful when you are running Emacs
remotely on a server and you want to be able to log out and return to
your work later: if you quit the terminal process using =C-x C-c=
(=M-x save-buffers-kill-terminal=), the server continues running in
the background. You can kill the server from within Emacs using =M-x
save-buffers-kill-emacs=.

** option as Meta (=M-=) on a Mac

I use Emacs from a variety of terminal types on my machines running OS
X:

- the Cocoa version when working locally
- X11 when working remotely over a fast connection
- a terminal application when working remotely over a slow connection

I have done my best to configure all three to provide an experience
that's as comparable as possible. Here are some configuration
suggestions to use the option key as Meta (=M-=), as opposed to Esc.

*** Cocoa

I just download it from http://emacsformacosx.com/ - as far as I can
tell, option is used as Meta by default.

*** X11

I use [[http://xquartz.macosforge.org/downloads/SL/XQuartz-2.7.7.dmg][XQuartz]]

Create the file ~/.Xmodmap as follows to use option as Meta in X11
(you'll need to quit X11 for the changes to take effect):

#+BEGIN_SRC sh
cat > ~/.Xmodmap <<EOF
clear Mod1
clear Mod2
keycode 63 = Mode_switch
keycode 66 = Meta_L
add Mod1 = Meta_L
add Mod2 = Mode_switch
EOF
#+END_SRC

[[http://tylerkieft.com/archives/2006/10/05/redefine-the-x11-meta-key-in-mac-os-x/][This post]] has more information on configuring X11.

*** Terminal

I prefer [[http://iterm2.com/][iTerm2]] over Terminal.app

Head over to Preferences --> Profiles --> Keys and do these things:

- select "Left/right option key acts as": +Esc (to use option as Meta)
- + --> Keyboard shortcut "OPT+<left arrow>": Send Escape sequence "b"
- + --> Keyboard shortcut "OPT+<right arrow>": Send Escape sequence "f"

The last two items cause option plus the right and left arrows to
perform the same actions as =M-f= (=forward-word=) and =M-b=
(=backward-word=) in both Emacs and in contexts that support default
readline key bindings (which is [[https://coderwall.com/p/usc8qg][just about everywhere]]).

*** What next?
If you are completely new to Emacs, the very first thing to do is to
become acquainted with the built-in help system. You can get to the
help menu by typing =<f1>= or =C-h ?=.

Next, I'd recommend starting with the built in tutorial by typing =C-h
t=.
** install packages from ELPA

The only required step to use this configuration is to install
packages from EPLA, the Emacs Lisp Package Archive. See the "ELPA"
section below for a list of packages installed by this configuration
(defined in =my-package-list=). First, launch Emacs; I'd recommend
launching without emacs-desktop, for example =emacs -nw
--no-desktop=. Install specified packages with =M-x
install-packages= (see the *ELPA* section below). At this point
it's usually a good idea to quit and relaunch Emacs.

** create virtualenv

The packages used here (particularly =elpy=) require some python
bits. The easiest way to provide them is to install them in a
virtualenv. There's a script to do this - just run:

#+BEGIN_SRC sh :eval no
bin/venv.sh
#+END_SRC

This will create =~/.emacs.d/emacs-env=. If =scons= isn't installed,
this will add that, too. In this case, you'll need to activate the
virtualenv (=source emacs-env/bin/activate=) to use the version of
=scons= installed there. I'll explain later why having =scons= is
useful.

** initialize org-export submodule (optional)

If you want to compile =init.org= to html using the provided build
script, you'll need to initialize and update the git [[http://git-scm.com/book/en/Git-Tools-Submodules][submodule]]
containing the =org-export= project
(https://github.com/nhoffman/org-export). This only needs to be done
once after checking out this repository:

#+BEGIN_SRC sh
git submodule update --init
#+END_SRC

To update the =org-export= repository, first try

#+BEGIN_SRC sh
git submodule update
#+END_SRC

This will update to whatever commit is associated with the project, eg

#+BEGIN_SRC sh :eval yes :results output :exports both
git submodule status
#+END_SRC

If this doesn't do anything, try

#+BEGIN_SRC sh
(cd org-export && git checkout org-export && git pull origin master)
#+END_SRC

If there were any changes, you'll need to make a commit in
=.emacs.d=. Ugh, submodules.

* Using and maintaining this configuration

All changes to the configuration should be made within code blocks in
this file. After any changes, this file must be "tangled" to produce
=init.el=. The elisp version of the configuration is committed to the
git repository (even though it is a derived file) to make it easier to
get started when first cloning the repository onto a new system. An
html-exported version of this file is also published to GitHub
pages. All of this is automated using =scons=. The default target is
=init.el=, so after changing this file, you can compile =init.el= by
simply typing

: scons

If you'd rather tangle the file interactively, use =C-c C-v t=
(=org-babel-tangle=).

Additional targets include =scons html= to compile =html/index.html=
and =scons publish= to update the =gh-pages= branch of the repo on
GitHub.

To help keep track of functions I've defined, I like to make aliases
that prepend the value of `my-alias-prefix'. Here's a function to help
with making aliases.

#+BEGIN_SRC elisp
(defvar my-alias-prefix "my/")

(defun make-alias (fun &optional prefix)
  "Create an alias for function `fun' by prepending the value of
  `my-alias-prefix' to the symbol name. Use `prefix' to provide
  an alternative prefix string. Example:

  (defun bar () (message \"I am bar\"))
  (make-alias 'bar \"foo-\")
  (foo-bar) => \"I am bar\""

  (interactive)
  (defalias
    (intern (concat (or prefix my-alias-prefix) (symbol-name fun)))
    fun))
#+END_SRC

I edit this file so frequently, let's make some functions to find,
tangle, and load it.

#+BEGIN_SRC elisp
(defvar my/init-org "~/.emacs.d/init.org" "org-mode version of init file")
(defvar my/init-el "~/.emacs.d/init.el" "tangled version of `my/init-org'")

(defun init-edit ()
  "Edit org-mode version of init file specified by `my/init-org'"
  (interactive)
  (find-file my/init-org))
(make-alias 'init-edit)

(defun init-load ()
  (interactive)
  (load my/init-el))
(make-alias 'init-load)

(defun init-tangle-and-load ()
  "Tangle `my/init-org' and load the result"
  (interactive)
  (init-edit)
  (org-babel-tangle)
  (init-load)
  (switch-to-buffer "*Messages*"))
(make-alias 'init-tangle-and-load)
#+END_SRC

* Startup

This will only work with emacs 24.x

#+BEGIN_SRC elisp
(unless (= emacs-major-version 24)
  (error "Emacs version 24 is required"))
#+END_SRC

#+BEGIN_SRC elisp
(message "loading ~/.emacs.d/init.el")
#+END_SRC

** Auto-refresh

automatically refresh buffers from disk (default is every 5 sec)
see http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Reverting

#+BEGIN_SRC elisp
(global-auto-revert-mode 1)
#+END_SRC

** Enable debugging

#+BEGIN_SRC elisp
;; (setq debug-on-error t)
;; (setq debug-on-signal t)
#+END_SRC

** dir-local variables

I can't explain why, but I started getting errors that a
=.dir-locals.el= file high up in the file system could not be found
when opening a new file in emacsclient. This seems to have stopped the
error (conveniently, I don't use this feature):

#+BEGIN_SRC elisp
(setq enable-dir-local-variables nil)
#+END_SRC

* ELPA

Set up and initialize ELPA package manager.

Some useful ELPA variables and functions:

| =M-x package-list-packages= | open list of packages                                                 |
| =package-activated-list=    | variable containing list of the names of currently activated packages |
| =package-install=           | install a package                                                     |
| =package-installed-p=       | return true if package is installed                                   |

** define repositories

Add some extra package repositories. The default value of package-archives is
=(("gnu" . "http://elpa.gnu.org/packages/"))=

#+BEGIN_SRC elisp
(when (>= emacs-major-version 24)
  (require 'package)
  (setq package-archives
        '(("ELPA" . "http://tromey.com/elpa/")
          ("gnu" . "http://elpa.gnu.org/packages/")
          ("melpa" . "http://melpa.org/packages/")
          ("melpa-stable" . "http://stable.melpa.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")
          ("org" . "http://orgmode.org/elpa/")
          ("elpy" . "http://jorgenschaefer.github.io/packages/")
          ))

  ;; Check if we're on Emacs 24.4 or newer, if so, use the pinned package feature
  ;; note that elpy installation fails when pinned to elpy package
  (when (boundp 'package-pinned-packages)
    (setq package-pinned-packages
          '((elpy . "elpy")
            (highlight-indentation . "elpy") ;; fixes error in elpy 1.6
            (org . "org")
            (magit . "melpa-stable")
            (helm-descbinds . "melpa-stable")
            (helm-swoop . "melpa-stable")
            (hydra . "gnu")
            )))

  (package-initialize))
#+END_SRC

** define a list of packages

I could not find an obvious way to define a list of packages to
automatically install, so here are some functions to do so. Execute
=M-x install-packages= to install any missing packages. Note that
when installing org-mode from ELPA for the first time, you must be
sure that the builtin version of org-mode has not been loaded since
emacs was first started.

#+BEGIN_SRC elisp
(defun package-installed-not-builtin-p (package &optional min-version)
  "Return true if PACKAGE, of MIN-VERSION or newer, is installed
(ignoring built-in versions).  MIN-VERSION should be a version list"

  (unless package--initialized (error "package.el is not yet initialized!"))
(if (< emacs-major-version 4)
    ;; < emacs 24.4
    (let ((pkg-desc (assq package package-alist)))
      (if pkg-desc
          (version-list-<= min-version
                           (package-desc-vers (cdr pkg-desc)))))
  ;; >= emacs 24.4
  (let ((pkg-descs (cdr (assq package package-alist))))
    (and pkg-descs
         (version-list-<= min-version
                          (package-desc-version (car pkg-descs)))))
  ))

(defun package-install-list (pkg-list)
  ;; Install each package in pkg-list if necessary.
  (mapcar
   (lambda (pkg)
     (unless (package-installed-not-builtin-p pkg)
       (package-install pkg)))
   pkg-list)
  (message "done installing packages"))

(defvar my-package-list
  '(ace-jump-mode
    ace-jump-buffer
    auctex
    csv-mode
    discover
    edit-server
    elpy
    ess
    expand-region
    gist
    git-timemachine
    helm
    helm-descbinds
    helm-swoop
    helm-projectile
    htmlize
    hydra
    jinja2-mode
    magit
    markdown-mode
    moinmoin-mode
    org
    projectile
    rainbow-delimiters
    visual-regexp
    visual-regexp-steroids
    yaml-mode
    yas-jit))

(defun install-packages ()
  ;; Install packages listed in global 'my-package-list'
  (interactive)
  (package-list-packages)
  (package-install-list my-package-list))
(make-alias 'install-packages)
#+END_SRC

* hydra

[[https://github.com/abo-abo/hydra][Hydra]] is "a package for GNU Emacs that can be used to tie related
commands into a family of short bindings with a common prefix." I
define various hyrdas as entry points to various commands below. For
now, I'll just be sure to test if =hydra= is installed each time I
call =defhydra=. For example:

: (if (require 'hydra nil 'noerror)
:     (progn (message "** hydra is installed"))
:   (message "** hydra is not installed"))

** hydra-toggle-mode

A hydra for toggling modes. Activate via =hydra-launcher= using =C-l g=

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn
      (defhydra hydra-toggle-mode (:color blue :columns 4 :post (redraw-display))
        "hydra-toggle-mode"
        ("RET" redraw-display "<quit>")
        ("c" csv-mode "csv-mode")
        ("j" jinja2-mode "jinja2-mode")
        ("k" markdown-mode "markdown-mode")
        ("l" lineum-mode "lineum-mode")
        ("m" moinmoin-mode "moinmoin-mode")
        ("o" org-mode "org-mode")
        ("p" python-mode "python-mode")
        ("r" R-mode "R-mode")
        ("s" sql-mode "sql-mode")
        ("t" text-mode "text-mode")
        ("v" visual-line-mode "visual-line-mode")
        ("y" yaml-mode "yaml-mode")
        ))
  (message "** hydra is not installed"))
#+END_SRC

* sidestepping customize

Cribbed from a [[http://oremacs.com/2015/01/17/setting-up-ediff/][post]] on oremacs, this macro provides "a setq that is
aware of the custom-set property of a variable."

#+BEGIN_SRC elisp
(defmacro csetq (variable value)
  `(funcall (or (get ',variable 'custom-set)
                'set-default)
            ',variable ,value))
#+END_SRC

* Navigation
** =electric-buffer-list=

Replace default =list-buffers= with =electric-buffer-list= for buffer
selection.

#+BEGIN_SRC elisp
(global-set-key (kbd "C-x C-b") 'electric-buffer-list)
#+END_SRC

** Switch windows with arrow keys

Note that other-window is bound by default to =C-x o=

#+BEGIN_SRC elisp
(defun back-window ()
  (interactive)
  (other-window -1))
(global-set-key (kbd "C-<right>") 'other-window)
(global-set-key (kbd "C-<left>") 'back-window)
#+END_SRC

** helm

Helm is a pretty intense change to the default behavior for executing
commands, switching buffers, finding files, etc. It takes some getting
used to, but woah.

See http://tuhdo.github.io/helm-intro.html for setup suggestions.

Using the configuration below, some hints:

- When in the =helm-M-x= buffer, =TAB= shows documentation for the selected command.
- As suggested, I've replaced the default behavior of =M-y= to use
  helm's equivalent, which shows a menu of recently copied regions
  (rather than cycling through entries of the kill ring after a yank).

#+BEGIN_SRC elisp
(condition-case nil
    (progn
      (require 'helm-config)
      (helm-mode 1)
      (global-set-key (kbd "M-x") 'helm-M-x)
      (global-set-key (kbd "C-x C-f") 'helm-find-files)
      (global-set-key (kbd "M-y") 'helm-show-kill-ring)
      (global-set-key (kbd "C-c h o") 'helm-occur)
      (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
      (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
      (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
      (define-key helm-map (kbd "C-z")  'helm-select-action)
      )
  (error (message "** could not activate helm")))
#+END_SRC

** helm-descbinds

Describe key bindings for the current modes: see https://github.com/emacs-helm/helm-descbinds

#+BEGIN_SRC elisp
(condition-case nil
    (progn
      (require 'helm-descbinds)
      (global-set-key (kbd "C-h b") 'helm-descbinds))
  (error (message "** could not activate helm-descbinds")))
#+END_SRC

** hydra for helm

A hydra for activating helm commands that I can't otherwise
remember. Activate via =hydra-launcher= using =C-l h=

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn
      (defhydra hydra-helm (:color blue :columns 4 :post (redraw-display))
        "hydra-toggle-mode"
        ("RET" redraw-display "<quit>")
        ("b" helm-browse-project "helm-browse-project")
        ("d" helm-descbinds "helm-descbinds")
        ("f" helm-projectile-find-file-dwim "helm-projectile-find-file-dwim")
        ("g" helm-projectile-grep "helm-projectile-grep")
        ("j" helm-projectile-switch-project "helm-projectile-switch-project")
        ("o" helm-occur "helm-occur")
        ("O" helm-org-in-buffer-headings "helm-org-in-buffer-headings")
        ("p" helm-projectile "helm-projectile")
        ("s" helm-swoop "helm-swoop")
        ))
  (message "** hydra is not installed"))
#+END_SRC

** TODO projectile and helm-projectile

TODO: check out =helm-projectile=

Project-centric file and directory navigation - see
https://github.com/bbatsov/projectile

Installed using ELPA.

Basic key bindings (see the url above for a complete list).

| keybinding | description                                       |
| C-c p C-h  | Help with projectile key bindings                 |
| C-c p f    | Display a list of all files in the project.       |
| C-c p d    | Display a list of all directories in the project. |

projectile is integrated with helm by the package
helm-projectile. Usage information is here:
http://tuhdo.github.io/helm-projectile.html

We'll configure both together

#+BEGIN_SRC elisp
(if (and (package-installed-p 'projectile) (package-installed-p 'helm-projectile))
    (progn
      (projectile-global-mode)
      (setq projectile-completion-system 'helm)
      (helm-projectile-on))
  (message "** not using projectile or helm-projectile - one or both not installed"))
#+END_SRC

** ibuffer

- http://emacs-fu.blogspot.com/2010/02/dealing-with-many-buffers-ibuffer.html

I used to rely heavily on =ibuffer= to manage lots of open buffers,
but now it's so easy to search for buffers by name with =helm= that I
rarely use it any more.

#+BEGIN_SRC elisp
(require 'ibuffer)
(global-set-key (kbd "C-x C-g") 'ibuffer)
(global-set-key (kbd "C-x M-g") 'ibuffer-switch-to-saved-filter-groups)
(setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

Function to load config file. Load on starup.

#+BEGIN_SRC elisp
(defvar my-ibuffer-config-file "~/.emacs.d/ibuffer-config.el")

(defun ibuffer-load-config ()
  ;; load the ibuffer config file
  (interactive)
  (condition-case nil
      (progn
	(message (format "** loading ibuffer config in %s" my-ibuffer-config-file))
	(load my-ibuffer-config-file)
	)
    (error (message (format "** could not load %s" my-ibuffer-config-file))))
  )

(ibuffer-load-config)
#+END_SRC

Show/hide all filter groups

#+BEGIN_SRC elisp
(defun ibuffer-show-all-filter-groups ()
  "Show all filter groups"
  (interactive)
  (setq ibuffer-hidden-filter-groups nil)
  (ibuffer-update nil t))

(defun ibuffer-hide-all-filter-groups ()
  "Hide all filter groups"
  (interactive)
  (setq ibuffer-hidden-filter-groups
	(delete-dups
	 (append ibuffer-hidden-filter-groups
		 (mapcar 'car (ibuffer-generate-filter-groups
			       (ibuffer-current-state-list)
			       (not ibuffer-show-empty-filter-groups)
			       t)))))
  (ibuffer-update nil t))
#+END_SRC

#+BEGIN_SRC elisp
(defun ibuffer-reload ()
  ;; kill ibuffer, reload the config file, and return to ibuffer
  (interactive)
  (ibuffer)
  (kill-buffer)
  (ibuffer-load-config)
  (ibuffer)
  )
#+END_SRC

From http://www.emacswiki.org/emacs/IbufferMode

#+BEGIN_SRC elisp
(defun my-ibuffer-sort-hook ()
  ;; add another sorting method for ibuffer (allow the grouping of
  ;; filenames and dired buffers
  (define-ibuffer-sorter filename-or-dired
    "Sort the buffers by their pathname."
    (:description "filenames plus dired")
    (string-lessp
     (with-current-buffer (car a)
       (or buffer-file-name
	   (if (eq major-mode 'dired-mode)
	       (expand-file-name dired-directory))
	   ;; so that all non pathnames are at the end
	   "~"))
     (with-current-buffer (car b)
       (or buffer-file-name
	   (if (eq major-mode 'dired-mode)
	       (expand-file-name dired-directory))
	   ;; so that all non pathnames are at the end
	   "~"))))
  (define-key ibuffer-mode-map (kbd "s p")     'ibuffer-do-sort-by-filename-or-dired)
  )
#+END_SRC

From http://curiousprogrammer.wordpress.com/2009/04/02/ibuffer/

#+BEGIN_SRC elisp
(defun ibuffer-ediff-marked-buffers ()
  "Compare two marked buffers using ediff"
  (interactive)
  (let* ((marked-buffers (ibuffer-get-marked-buffers))
         (len (length marked-buffers)))
    (unless (= 2 len)
      (error (format "%s buffer%s been marked (needs to be 2)"
                     len (if (= len 1) " has" "s have"))))
    (ediff-buffers (car marked-buffers) (cadr marked-buffers))))
#+END_SRC

Hooks

#+BEGIN_SRC elisp
(add-hook 'ibuffer-mode-hook
          '(lambda ()
             (ibuffer-auto-mode 1) ;; minor mode that keeps the buffer list up to date
             (ibuffer-switch-to-saved-filter-groups "default")
             (define-key ibuffer-mode-map (kbd "a") 'ibuffer-show-all-filter-groups)
             (define-key ibuffer-mode-map (kbd "z") 'ibuffer-hide-all-filter-groups)
             (define-key ibuffer-mode-map (kbd "e") 'ibuffer-ediff-marked-buffers)
             (my-ibuffer-sort-hook)
             ;; don't accidentally print; see http://irreal.org/blog/?p=2013
             (defadvice ibuffer-do-print (before print-buffer-query activate)
               (unless (y-or-n-p "Print buffer? ")
                 (error "Cancelled")))
             )
          )
#+END_SRC

** uniquify

Distinguish buffer names for identically-named files.

- http://www.emacswiki.org/emacs/uniquify
- Note that as of 24.4, uniquify is enabled by default, but with
  =uniquify-buffer-name-style= set to =post-forward-angle-brackets=.

#+BEGIN_SRC elisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward)
#+END_SRC

* Marking, cursor movement and appearance
** ace-jump-mode

A quick cursor location minor mode for emacs. I picked =M-'= as the
key combo for activation. Installed from ELPA.

#+BEGIN_SRC elisp
(define-key global-map (kbd "M-'") 'ace-jump-mode)
#+END_SRC

** expand-region

#+BEGIN_QUOTE
Expand region increases the selected region by semantic units. Just
keep pressing the key until it selects what you want.
#+END_QUOTE

Installed using ELPA.

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn
      (defhydra hydra-expand-region (global-map "M-=")
        "hydra-expand-region"
        ("=" er/expand-region "er/expand-region")
        ("-" er/contract-region "er/contract-region")))
  (message "** hydra is not installed"))
#+END_SRC

* Define a "launcher" keymap

Use a =hydra= to define a key map containing a grab-bag of commonly
used functions. Much easier than trying to find unused key
combinations.

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn
      (defhydra hydra-launcher (:color teal :columns 4 :post (redraw-display))
        "hydra-launcher"
        ("C-g" redraw-display "<quit>")
        ("d" insert-date "insert-date")
        ("D" describe-minor-mode "describe-minor-mode")
        ("e" save-buffers-kill-emacs "save-buffers-kill-emacs")
        ("f" fix-frame "fix-frame")
        ("g" hydra-toggle-mode/body "toggle mode")
        ("h" hydra-helm/body "helm commands")
        ("i" init-edit "init-edit")
        ("n" my/find-org-index "my/find-org-index")
        ("N" my/org-index-add-entry "my/org-index-add-entry")
        ("m" magit-status "magit-status")
        ("o" copy-region-or-line-other-window "copy-region-or-line-other-window")
        ("p" list-processes "list-processes")
        ("r" redraw-display "redraw-display")
        ("s" ssh-refresh "ssh-refresh")
        ("t" org-todo-list "org-todo-list")
        ("v" activate-venv "activate-venv"))

      (global-set-key (kbd "C-c l") 'hydra-launcher/body)
      (global-set-key (kbd "M-,") 'hydra-launcher/body))
  (message "** hydra is not installed"))
#+END_SRC

* Function keys.

It's kind of surprising that the function keys aren't
either defined or bound to more commonly used functions by
default.

|-----+--------------------------------------+---------------+----------------------|
| key | default binding                      | also bound to | my binding           |
|-----+--------------------------------------+---------------+----------------------|
| f1  | view-order-manuals                   | C-h           |                      |
| f2  | 2C-command                           | C-x 6         | fix-frame            |
| f3  | kmacro-start-macro-or-insert-counter |               |                      |
| f4  | kmacro-end-or-call-macro             |               |                      |
| f5  |                                      |               | call-last-kbd-macro  |
| f6  |                                      |               | lineum-mode          |
| f7  |                                      |               | visual-line-mode     |
| f8  |                                      |               | ns-toggle-fullscreen |
| f9  |                                      |               |                      |
| f10 | menu-bar-open                        |               |                      |
| f11 | (OS X: Show Desktop)                 |               |                      |
| f12 | (OS X: Show Dashboard)               |               |                      |

#+BEGIN_SRC elisp
(global-set-key (kbd "<f6>") 'linum-mode)
(global-set-key (kbd "<f7>") 'visual-line-mode)
(global-set-key (kbd "<f8>") 'flymake-popup-current-error-menu)
#+END_SRC

#+BEGIN_SRC elisp
(defalias 'dtw 'delete-trailing-whitespace)
#+END_SRC

* General appearance

#+BEGIN_SRC elisp
(setq column-number-mode t)
(setq inhibit-splash-screen t)
(setq require-final-newline t)
(setq make-backup-files nil)
(setq initial-scratch-message nil)
(setq suggest-key-bindings 4)
(show-paren-mode 1)
#+END_SRC

** status bar

Date and time in status bar. See http://efod.se/writings/linuxbook/html/date-and-time.html

#+BEGIN_SRC elisp
(setq display-time-day-and-date t
      display-time-24hr-format t)
(display-time)
#+END_SRC

** title bar

File path in title bar. See http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer

#+BEGIN_SRC elisp
(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
            '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
#+END_SRC

** Prettier cursor

#+BEGIN_SRC elisp
(set-cursor-color "red")
(blink-cursor-mode 1)
#+END_SRC

* Environment
** update load path

Store packages not available via elpa in =~./.emacs.d/elisp=

#+BEGIN_SRC elisp
(add-to-list 'load-path "~/.emacs.d/elisp/")
#+END_SRC

** update SSH_AUTH_SOCK

If you 1) forward ssh authentication (ie, ssh -A), 2) have a
long-running emacs --daemon and 3) set an expiration on your ssh
authentication, then you will lose the ability to perform ssh public
key authentication once the authentication expires. So actions like
pushing/pulling using magit will fail. This can be addressed by
updating the value of the SSH_AUTH_SOCK environment variable. Here's a
function to fix this.

After installing El Capitan, I've had to follow the instructions [[https://coderwall.com/p/qdwcpg/using-the-latest-ssh-from-homebrew-on-osx][here]]
to make ssh-agent work with the version of openssh installed via
Homebrew. Using this scheme, =~/.ssh-auth-sock= stores the value of
=SSH_AUTH_SOCK=.

#+BEGIN_SRC elisp
(defun ssh-refresh ()
  "Reset the environment variable SSH_AUTH_SOCK"
  (interactive)
  (let (ssh-auth-sock-old (getenv "SSH_AUTH_SOCK"))
    (setenv "SSH_AUTH_SOCK"
            (car (split-string
                  (shell-command-to-string
                   (if (eq system-type 'darwin)
                       "cat ~/.ssh-auth-sock"
                     ;; "ls -t $(find /tmp/* -user $USER -name Listeners 2> /dev/null)"
                     "ls -t $(find /tmp/ssh-* -user $USER -name 'agent.*' 2> /dev/null)"
                     )))))
    (message
     (format "SSH_AUTH_SOCK %s --> %s"
             ssh-auth-sock-old (getenv "SSH_AUTH_SOCK")))))
(make-alias 'ssh-refresh)
#+END_SRC
** PATH setup
Add paths to 'exec-path' so that Emacs can find executables not
otherwise defined in PATH.

#+BEGIN_SRC elisp
(add-to-list 'exec-path "~/.emacs.d/bin")
#+END_SRC

Also update the =$PATH= environment variable inherited by shell
commands run from within Emacs.

#+BEGIN_SRC elisp
(defun prepend-path (path)
  "Add `path' to the beginning of $PATH unless already present."
  (interactive)
  (unless (string-match path (getenv "PATH"))
    (setenv "PATH" (concat path ":" (getenv "PATH")))))

(prepend-path "~/.emacs.d/bin")
#+END_SRC

** exec-path-from-shell

Initialize the PATH environment variable when starting up the Emacs
app from the finder. Found this tip here: https://plus.google.com/104330705025733851532/posts/K6YPSVEB9Nx

Commenting out for now, but seems promising....

#+BEGIN_SRC elisp
  ;; (when (memq window-system '(mac ns))
  ;;   (exec-path-from-shell-initialize))
#+END_SRC

* Exiting and saving

Require prompt before exit on C-x C-c
- http://www.dotemacs.de/dotfiles/KilianAFoth.emacs.html

#+BEGIN_SRC elisp
(global-set-key [(control x) (control c)]
		(function
		 (lambda () (interactive)
		   (cond ((y-or-n-p "Quit? (save-buffers-kill-terminal) ")
			  (save-buffers-kill-terminal))))))
#+END_SRC

Delete trailing whitespace before save.

#+BEGIN_SRC elisp
(setq delete-trailing-lines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* Platform and display-specific settings

Detect platform and window system and set up fonts and other
system-specific settings accordingly. It may be necessary to run =M-x
fix-frame= after opening a new frame attached to a running emacs
server process.

#+BEGIN_SRC elisp
(defun set-default-font-verbosely (font-name)
  (interactive)
  (message (format "** setting default font to %s" font-name))
  (condition-case nil
      (set-default-font font-name)
    (error (message (format "** Error: could not set to font %s" font-name)))))

(defun fix-frame (&optional frame)
  "Apply platform-specific settings."
  (interactive)
  (menu-bar-mode -1)    ;; hide menu bar
  (tool-bar-mode -1)    ;; hide tool bar
  (scroll-bar-mode -1)  ;; hide scroll bar
  (cond ((string= "ns" window-system) ;; cocoa
         (progn
           (message (format "** running %s windowing system" window-system))
           ;; key bindings for mac - see
           ;; http://stuff-things.net/2009/01/06/emacs-on-the-mac/
           ;; http://osx.iusethis.com/app/carbonemacspackage
           (set-keyboard-coding-system 'mac-roman)
           (setq mac-option-modifier 'meta)
           (setq mac-command-key-is-meta nil)
           (set-default-font-verbosely "Bitstream Vera Sans Mono-14")))
        ((string= "x" window-system)
         (progn
           (message (format "** running %s windowing system" window-system))
           (set-default-font-verbosely "Liberation Mono-10")
           ;; M-w or C-w copies to system clipboard
           ;; see http://www.gnu.org/software/emacs/elisp/html_node/Window-System-Selections.html
           (setq x-select-enable-clipboard t)))
        (t
         (message "** running in terminal mode"))))
(global-set-key (kbd "<f2>") 'fix-frame)
(make-alias 'fix-frame)
(fix-frame)
#+END_SRC

* Scrolling

See http://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC elisp
(setq mouse-wheel-scroll-amount '(3 ((shift) . 3))) ;; number of lines at a time
(setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
(setq mouse-wheel-follow-mosue 't)                  ;; scroll window under mouse
(setq scroll-step 1)                                ;; keyboard scroll one line at a time
(setq scroll-conservatively 1)                      ;; scroll by one line to follow cursor off screen
(setq scroll-margin 2)                              ;; Start scrolling when 2 lines from top/bottom
#+END_SRC

* Keyboard macros

See http://www.emacswiki.org/emacs/KeyboardMacros
note that default bindings for macros are:

| C-x ( | start defining a keyboard macro  |
| C-x ) | stop defining the keyboard macro |
| C-x e | execute the keyboard macro       |

Some additional keyboard macro bindings.

#+BEGIN_SRC elisp
(global-set-key (kbd "<f5>") 'call-last-kbd-macro)
#+END_SRC

* ediff
Always split windows horizontally.

#+BEGIN_SRC elisp
(csetq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

* emacs desktop

References:
- http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html
- http://www.emacswiki.org/emacs/DeskTop

Save desktop periodically instead of just on exit, but not if emacs is
started with =--no-desktop=. Note that "--no-desktop" is deleted from
`command-line-args' when desktop is activated, so we have to check
before that.

#+BEGIN_SRC elisp
(defun desktop-save-no-p ()
  "Save desktop without prompting (replaces `desktop-save-in-desktop-dir')"
  (interactive)
  ;; (message (format "Saving desktop in %s" desktop-dirname))
  (desktop-save desktop-dirname))

(if (member "--no-desktop" command-line-args)
    (message "** desktop auto-save is disabled")
  (progn
    (require 'desktop)
    (desktop-save-mode 1)
    (message "** desktop auto-save is enabled")
    (add-hook 'auto-save-hook 'desktop-save-no-p)))
#+END_SRC

When the server is running, start with the first buffer with a name
not starting with a star or space.

(not working yet, alas!)

#+BEGIN_SRC elisp
;; (defun buffer-list-nostar ()
;;     (delq nil (mapcar
;;                (lambda (buf)
;;                  (unless (string-match "^[* ]" (buffer-name buf)) buf))
;;                (buffer-list))))

;; (add-hook 'before-make-frame-hook
;;           (lambda ()
;;             (message "** running 'before-make-frame-hook")
;;             ;; (let ((buf (buffer-file-name (car (buffer-list-nostar)))))
;;             ;;   (print (buffer-list-nostar))
;;             ;;   (when buf
;;             ;;     (setq initial-buffer-choice buf)
;;             ;;     (message "** setting initial buffer to %s" buf)))

;;             (print (buffer-list))
;;             (setq initial-buffer-choice (buffer-file-name (car (delq nil (mapcar
;;                (lambda (buf)
;;                  (unless (string-match "^[* ]" (buffer-name buf)) buf))
;;                (buffer-list))))))
;;             ))
#+END_SRC

* Move lines up and down with arrow keys

See http://stackoverflow.com/questions/2423834/move-line-region-up-and-down-in-emacs

Move line up

#+BEGIN_SRC elisp
(defun move-line-up ()
  (interactive)
  (transpose-lines 1)
  (previous-line 2))
(global-set-key (kbd "M-<up>") 'move-line-up)
#+END_SRC

Move line down.

#+BEGIN_SRC elisp
(defun move-line-down ()
  (interactive)
  (next-line 1)
  (transpose-lines 1)
  (previous-line 1))
(global-set-key (kbd "M-<down>") 'move-line-down)
#+END_SRC

* Buffers and windows
** Transpose buffers

- see http://www.emacswiki.org/emacs/SwitchingBuffers
- note that original code used function 'plusp', which seems not to be defined in recent versions of emacs

#+BEGIN_SRC elisp
(defun transpose-buffers (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      ;; (setq arg (if (plusp arg) (1- arg) (1+ arg)))
      (setq arg (if (>= arg 0) (1- arg) (1+ arg)))
      )))
(global-set-key (kbd "C-x 4") 'transpose-buffers)
#+END_SRC

** Switch buffers between frames

Also from http://www.emacswiki.org/emacs/SwitchingBuffers

#+BEGIN_SRC elisp
(defun switch-buffers-between-frames ()
  "switch-buffers-between-frames switches the buffers between the two last frames"
  (interactive)
  (let ((this-frame-buffer nil)
	(other-frame-buffer nil))
    (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
    (other-frame 1)
    (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
    (switch-to-buffer this-frame-buffer)
    (other-frame 1)
    (switch-to-buffer other-frame-buffer)))
(global-set-key (kbd "C-x 5") 'switch-buffers-between-frames)
#+END_SRC

** Toggle frame split

Toggles between a horizontal and vertical split (two frames only).

Copied from http://www.emacswiki.org/emacs/ToggleWindowSplit (submitted by Wilfred).

#+BEGIN_SRC elisp
  (defun toggle-frame-split ()
    "If the frame is split vertically, split it horizontally or vice versa.
  Assumes that the frame is only split into two."
    (interactive)
    (unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
    (let ((split-vertically-p (window-combined-p)))
      (delete-window) ; closes current window
      (if split-vertically-p
          (split-window-horizontally)
        (split-window-vertically)) ; gives us a split with the other window twice
      (switch-to-buffer nil))) ; restore the original window in this part of the frame

  (global-set-key (kbd "C-x 6") 'toggle-frame-split)
#+END_SRC

** Force horizontal splits

#+BEGIN_SRC elisp
(setq split-height-threshold nil)
#+END_SRC

** ace-jump-buffer

Quickly jump to another buffer by selecting a letter from a pop-up
menu (bind to =M-"=).

#+BEGIN_SRC elisp
(define-key global-map (kbd "M-\"") 'ace-jump-buffer)
#+END_SRC

* spelling

Use aspell instead of ispell

#+BEGIN_SRC elisp
(setq-default ispell-program-name "aspell")
(setq ispell-dictionary "en")
#+END_SRC

Enable on-the-fly spell-check

#+BEGIN_SRC elisp
(autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)
(setq flyspell-issue-welcome-flag nil) ;; fix error message
#+END_SRC

* pine/alpine

http://snarfed.org/space/emacs%20font-lock%20faces%20for%20composing%20email

#+BEGIN_SRC elisp
  (add-hook 'find-file-hooks
            '(lambda ()
               (if (equal "pico." (substring (buffer-name (current-buffer)) 0 5))
                   ;; (message "** running hook for pine/alpine")
                   (mail-mode))))
#+END_SRC

* LaTeX

Install AuxTeX from ELPA.

* ESS

Installed using ELPA, but seems to need =require= to be called
explicitly.

#+BEGIN_SRC elisp
(condition-case nil
    (require 'ess-site)
  (error (message "** could not load ESS")))
#+END_SRC

Hooks

#+BEGIN_SRC elisp
(add-hook 'ess-mode-hook
	  '(lambda()
	     (message "Loading ess-mode hooks")
	     ;; leave my underscore key alone!
	     (setq ess-S-assign "_")
	     ;; (ess-toggle-underscore nil)
	     ;; set ESS indentation style
	     ;; choose from GNU, BSD, K&R, CLB, and C++
	     (ess-set-style 'GNU 'quiet)
	     (flyspell-mode)
	     )
	  )
#+END_SRC

* org-mode

org-mode hooks

#+BEGIN_SRC elisp
(add-hook 'org-mode-hook
          '(lambda ()
             (message "Loading org-mode hooks")
             ;; (font-lock-mode)
             (setq org-confirm-babel-evaluate nil)
             (setq org-src-fontify-natively t)
             (setq org-edit-src-content-indentation 0)
             (define-key org-mode-map (kbd "M-<right>") 'forward-word)
             (define-key org-mode-map (kbd "M-<left>") 'backward-word)
             ;; provides key mapping for the above; replaces default
             ;; key bindings for org-promote/demote-subtree
             (define-key org-mode-map (kbd "M-S-<right>") 'org-do-demote)
             (define-key org-mode-map (kbd "M-S-<left>") 'org-do-promote)
             (define-key org-mode-map (kbd "C-c n")  'hydra-org-navigation/body)
             (visual-line-mode)
             ;; org-babel
             (org-babel-do-load-languages
              'org-babel-load-languages
              '((R . t)
                (latex . t)
                (python . t)
                (sh . t)
                (sql . t)
                (sqlite . t)
                (dot . t)
                ))
             ;; (defun org-with-silent-modifications(&rest args)
             ;;   "Replaces function causing error on org-export"
             ;;   (message "Using fake 'org-with-silent-modifications'"))
             (defadvice org-todo-list (after org-todo-list-bottom ())
               "Move to bottom of page after entering org-todo-list"
               (progn (end-of-buffer) (recenter-top-bottom)))
             (ad-activate 'org-todo-list)
             ))

(setq org-agenda-files (list "~/Dropbox/notes/index.org"))
(push '("\\.org\\'" . org-mode) auto-mode-alist)
(push '("\\.org\\.txt\\'" . org-mode) auto-mode-alist)
#+END_SRC

Custom key bindings
** navigation

I can't seem to remember the default bindings for navigation in
org-mode, so I made this hydra for movement between headings and code
blocks.

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn
      (defhydra hydra-org-navigation (:exit nil :foreign-keys warn)
        "hydra-org-navigation"
        ("i" org-previous-item "org-previous-item")
        ("k" org-next-item "org-next-item")
        ("<right>" org-next-block "org-next-block")
        ("<left>" org-previous-block "org-previous-block")
        ("<down>" outline-next-visible-heading "outline-next-visible-heading")
        ("<up>" outline-previous-visible-heading "outline-previous-visible-heading")
        ("S-<down>" org-forward-paragraph "org-forward-paragraph")
        ("S-<up>" org-backward-paragraph "org-backward-paragraph")
        ("q" nil "<quit>")))
  (message "** hydra is not installed"))
;; org-mode-map binds "C-c n" in org-mode-map

#+END_SRC

** org-mode utilities

#+BEGIN_SRC elisp
(defun insert-date ()
  ;; Insert today's timestamp in format "<%Y-%m-%d %a>"
  (interactive)
  (insert (format-time-string "<%Y-%m-%d %a>")))
(make-alias 'insert-date)
#+END_SRC

#+BEGIN_SRC elisp
(defun org-add-entry (filename time-format)
  ;; Add an entry to an org-file with today's timestamp.
  (interactive "FFile: ")
  (find-file filename)
  (end-of-buffer)
  (delete-blank-lines)
  (insert (format-time-string time-format)))
#+END_SRC

Add a new entry to main notes file.

#+BEGIN_SRC elisp
(defvar my/org-index "~/Dropbox/notes/index.org")

(defun my/org-index-add-entry ()
  (interactive)
  (org-add-entry my/org-index "\n* <%Y-%m-%d %a> "))

(defun my/find-org-index ()
  (interactive)
  (find-file my/org-index))
#+END_SRC

Add a new entry to my journal.

#+BEGIN_SRC elisp
(global-set-key
 (kbd "C-x C-j") (lambda () (interactive)
                   (org-add-entry "~/Dropbox/journal/journal.org"
                                  "\n* %A, %B %d, %Y")))
#+END_SRC

* markdown-mode

Installed using ELPA.

#+BEGIN_SRC elisp
(push '("\\.md" . markdown-mode) auto-mode-alist)
#+END_SRC

* chrome "edit with emacs"

'edit-server' is initialized by ELPA, but we need to start the server.

#+BEGIN_SRC elisp
(condition-case nil
    (edit-server-start)
  (error (message "** could not start edit-server (chrome edit with emacs)")))
#+END_SRC

* Python

- http://jesselegg.com/archives/2010/02/25/emacs-python-programmers-part-1/

** Python hooks

We'll use flake8 for syntax checking, but we want to be able to ignore
certain rules, so use a shell-script wrapper set the value of
=python-check-command= to use it.

#+BEGIN_SRC sh :exports both :results output
cat ~/.emacs.d/bin/pychecker
#+END_SRC

Error codes are listed here: http://pep8.readthedocs.org/en/latest/intro.html#error-codes

#+BEGIN_SRC elisp
(add-hook 'python-mode-hook
          '(lambda ()
             (message "Loading python-mode hooks")
             (setq indent-tabs-mode nil)
             (setq tab-width 4)
             (setq py-indent-offset tab-width)
             (setq py-smart-indentation t)
             (define-key python-mode-map "\C-m" 'newline-and-indent)
             (setq python-check-command "~/.emacs.d/bin/pychecker")
             ))
#+END_SRC

File name mappings

#+BEGIN_SRC elisp
(push '("SConstruct" . python-mode) auto-mode-alist)
(push '("SConscript" . python-mode) auto-mode-alist)
(push '("*.cgi" . python-mode) auto-mode-alist)
#+END_SRC

Default 'untabify converts a tab to equivalent number of spaces before
deleting a single character.

#+BEGIN_SRC elisp
(setq backward-delete-char-untabify-method "all")
#+END_SRC

** elpy

Along with some helper functions (see below) elpy has replaced a
number of python-related packages that I was using before, like
=jedi=, =flymake-cursor=, =flycheck=, and =python-pylint=.

- Installation :: https://github.com/jorgenschaefer/elpy/wiki/Installation
- note that =python-check-command= (set in python hooks above) defines the program used by =elpy-check=

#+BEGIN_SRC elisp
(condition-case nil
    (elpy-enable) ;; install from ELPA
  (error (message "** could not enable elpy")))
#+END_SRC

As of version 1.5.0, the elpy python package is distributed with the
ELPA elisp package, but other dependencies (such as jedi) still need
to be available. Assuming elpy dependencies are installed in
~/.emacs.d/emacs-env

#+BEGIN_SRC elisp
(defvar venv-default "~/.emacs.d/emacs-env")
(defun activate-venv-default ()
  (interactive)
  (pyvenv-activate venv-default)
  (elpy-rpc-restart))
(make-alias 'activate-venv-default)
#+END_SRC

Also add executables in the default virtualenv to =$PATH=

#+BEGIN_SRC elisp
(prepend-path "~/.emacs.d/emacs-env/bin")
#+END_SRC

Here's a function that tries to activate a virtualenv in the current
project.

#+BEGIN_SRC elisp
(defun activate-venv ()
  "Activate a virtualenv if one can be found in the current
project; otherwise activate the virtualenv defined in
`venv-default'. Also restarts the elpy rpc process."
  (interactive)
  (let ((venv nil)
        (find-pattern "find %s -path '*bin/activate' -maxdepth 4")
        (msg ""))

    (if (elpy-project-root)
        (setq venv
              (replace-regexp-in-string
               "/bin/activate[ \t\n]*" ""
               (shell-command-to-string
                (format find-pattern (elpy-project-root))))))

    (if (< (length venv) 1)
        (progn
          (setq venv venv-default)
          (setq msg "(cound not find a virtualenv here) ")))

    (if (y-or-n-p (format "%sActivate %s?" msg venv))
        (progn
          (pyvenv-activate venv)
          (elpy-rpc-restart)
          (message "Using %s" pyvenv-virtual-env)))))
(make-alias 'activate-venv)
#+END_SRC

This function installs python dependencies to the current virtualenv
from within Emacs.

#+BEGIN_SRC elisp
(defun elpy-install-requirements ()
  "Install python requirements to the current virtualenv."
  (interactive)
  (unless pyvenv-virtual-env
    (error "Error: no virtualenv is active"))
  (let ((dest "*elpy-install-requirements-output*")
        (install-cmd (format "%s/bin/pip install --force '%%s'" pyvenv-virtual-env))
        (deps '("jedi" "pyflakes" "pep8" "flake8" "importmagic")))
    (generate-new-buffer dest)
    (mapcar
     #'(lambda (pkg)
         (message (format install-cmd pkg))
         (call-process-shell-command (format install-cmd pkg) nil dest)) deps)
    (call-process-shell-command
     (format "%s/bin/pip freeze" pyvenv-virtual-env) nil dest)
    (switch-to-buffer dest))
  (elpy-rpc-restart))
(make-alias 'elpy-install-requirements)
#+END_SRC

I use =C-= + arrows to move between windows, and =M= + arrows to move
by word. These are in muscle memory at this point, and elpy can't have
them.

#+BEGIN_SRC elisp
(add-hook 'elpy-mode-hook
'(lambda ()
   (define-key elpy-mode-map (kbd "C-<right>") nil)
   (define-key elpy-mode-map (kbd "C-<left>") nil)
   (define-key elpy-mode-map (kbd "M-<right>") nil)
   (define-key elpy-mode-map (kbd "M-<left>") nil)
   (define-key elpy-mode-map (kbd "M-<right>") nil)
   (define-key elpy-mode-map (kbd "M-C-]") 'elpy-nav-move-iblock-right)
   (define-key elpy-mode-map (kbd "M-C-[") 'elpy-nav-move-iblock-left)
   (setq elpy-rpc-backend "jedi")
   (add-to-list 'elpy-project-ignored-directories "src")
   (add-to-list 'elpy-project-ignored-directories "*-env")
   ;; (elpy-use-ipython)
))
#+END_SRC


** autopep8

Apply =autopep8= (https://github.com/hhatto/autopep8) to the current
buffer. Reference: *Mastering Emacs*:
http://www.masteringemacs.org/articles/2011/10/19/executing-shell-commands-emacs/

#+BEGIN_SRC elisp
(defun p8 ()
  "Apply autopep8 to the current region or buffer"
  (interactive)
  (unless (region-active-p)
    (mark-whole-buffer))
  (shell-command-on-region
   (region-beginning) (region-end)      ;; beginning and end of region or buffer
   "autopep8 -"                         ;; command and parameters
   (current-buffer)                     ;; output buffer
   t                                    ;; replace?
   "*autopep8 errors*"                  ;; name of the error buffer
   t)                                   ;; show error buffer?
  (goto-char (region-end))              ;; ... and delete trailing newlines
  (re-search-backward "\n+" nil t)
  (replace-match "" nil t))
#+END_SRC

Instead of simply replacing the current buffer, use ediff to compare
it to the output of autopep8.

#+BEGIN_SRC elisp
(defun p8-and-ediff ()
  "Compare the current buffer to the output of autopep8 using ediff"
  (interactive)
  (let ((p8-output
         (get-buffer-create (format "* %s autopep8 *" (buffer-name)))))
    (shell-command-on-region
     (point-min) (point-max)    ;; beginning and end of buffer
     "autopep8 -"               ;; command and parameters
     p8-output                  ;; output buffer
     nil                        ;; replace?
     "*autopep8 errors*"        ;; name of the error buffer
     t)                         ;; show error buffer?
    (ediff-buffers (current-buffer) p8-output)))
#+END_SRC

* shell

Recognize zsh and bash scripts by file suffix.

#+BEGIN_SRC elisp
(add-to-list 'auto-mode-alist '("\\.zsh\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.bash\\'" . sh-mode))
#+END_SRC

* scons

I should really start using a snippet package, but for now:

#+BEGIN_SRC elisp
(defun scons-insert-command ()
  (interactive)
  (insert "output, = env.Command(
    target=,
    source=,
    action=('')
)"))
(make-alias 'scons-insert-command)
#+END_SRC

* text-mode

#+BEGIN_SRC elisp
(add-hook 'text-mode-hook
	  '(lambda ()
	     ;; (longlines-mode)
	     (flyspell-mode)
	     )
	  )
#+END_SRC

* rst-mode

#+BEGIN_SRC elisp
(add-hook 'rst-mode-hook
	  '(lambda ()
	     (message "Loading rst-mode hooks")
	     (flyspell-mode)
	     (define-key rst-mode-map (kbd "C-c C-a") 'rst-adjust)
	     )
	  )
#+END_SRC

* tramp

- http://www.gnu.org/software/tramp/

#+BEGIN_SRC elisp
(condition-case nil
    (require 'tramp)
  (setq tramp-default-method "scp")
  (error (message "** could not load tramp")))
#+END_SRC

* git/magit

#+BEGIN_SRC elisp
(require 'vc-git)
#+END_SRC

Magit is installed via ELPA.

#+BEGIN_SRC elisp
(global-set-key (kbd "C-c m") 'magit-status)
#+END_SRC

* sql support

- see http://atomized.org/2008/10/enhancing-emacs%E2%80%99-sql-mode/

Use sqlite3

#+BEGIN_SRC elisp
(setq sql-sqlite-program "sqlite3")
#+END_SRC

Preset connections

#+BEGIN_SRC elisp
(setq sql-connection-alist
      '((some-server
         (sql-product 'mysql)
         (sql-server "1.2.3.4")
         (sql-user "me")
         (sql-password "mypassword")
         (sql-database "thedb")
         (sql-port 3307))))

(defun sql-connect-preset (name)
  "Connect to a predefined SQL connection listed in `sql-connection-alist'"
  (eval `(let ,(cdr (assoc name sql-connection-alist))
    (flet ((sql-get-login (&rest what)))
      (sql-product-interactive sql-product)))))

(defun sql-mastermu ()
  (interactive)
  (sql-connect-preset 'mastermu))

;; buffer naming
(defun sql-make-smart-buffer-name ()
  "Return a string that can be used to rename a SQLi buffer.
This is used to set `sql-alternate-buffer-name' within
`sql-interactive-mode'."
  (or (and (boundp 'sql-name) sql-name)
      (concat (if (not(string= "" sql-server))
                  (concat
                   (or (and (string-match "[0-9.]+" sql-server) sql-server)
                       (car (split-string sql-server "\\.")))
                   "/"))
              sql-database)))

(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (setq sql-alternate-buffer-name (sql-make-smart-buffer-name))
            (sql-rename-buffer)))
#+END_SRC

* gpg

- http://www.emacswiki.org/emacs/EasyPG

#+BEGIN_SRC elisp
(require 'epa-file)
(setenv "GPG_AGENT_INFO" nil) ;; suppress graphical passphrase prompt
#+END_SRC
* Outline minor mode

The default key bindings for outline-minor-mode start with 'C-c @ C-',
which is... awkward. Use alternative bindings courtesy of Sue D. Nymme
via emacswiki (http://emacswiki.org/emacs/OutlineMinorMode).

#+BEGIN_SRC elisp
  ;; Outline-minor-mode key map
  (define-prefix-command 'cm-map nil "Outline-")
  ;; HIDE
  (define-key cm-map "q" 'hide-sublevels)    ; Hide everything but the top-level headings
  (define-key cm-map "t" 'hide-body)         ; Hide everything but headings (all body lines)
  (define-key cm-map "o" 'hide-other)        ; Hide other branches
  (define-key cm-map "c" 'hide-entry)        ; Hide this entry's body
  (define-key cm-map "l" 'hide-leaves)       ; Hide body lines in this entry and sub-entries
  (define-key cm-map "d" 'hide-subtree)      ; Hide everything in this entry and sub-entries
  ;; SHOW
  (define-key cm-map "a" 'show-all)          ; Show (expand) everything
  (define-key cm-map "e" 'show-entry)        ; Show this heading's body
  (define-key cm-map "i" 'show-children)     ; Show this heading's immediate child sub-headings
  (define-key cm-map "k" 'show-branches)     ; Show all sub-headings under this heading
  (define-key cm-map "s" 'show-subtree)      ; Show (expand) everything in this heading & below
  ;; MOVE
  (define-key cm-map "u" 'outline-up-heading)                ; Up
  (define-key cm-map "n" 'outline-next-visible-heading)      ; Next
  (define-key cm-map "p" 'outline-previous-visible-heading)  ; Previous
  (define-key cm-map "f" 'outline-forward-same-level)        ; Forward - same level
  (define-key cm-map "b" 'outline-backward-same-level)       ; Backward - same level
  ;; commands are prefixed with C-c o
  (global-set-key (kbd "C-c o") cm-map)

#+END_SRC

* Search and replace

Here are a few packages that make search and replace more fun. I'll
define a keymap using a hydra in the final section below.

** occur-dwim

Copied from [[http://oremacs.com/2015/01/26/occur-dwim/][a post]] on "(or emacs"

Note that plain-old =occur= can be executed using "M-s o" by default
(which I can never remember), of via =hyrda-search= defined below.

#+BEGIN_SRC elisp
(defun occur-dwim ()
  "Call `occur' with the current region (if active) or word."
  (interactive)
  (push (if (region-active-p)
            (buffer-substring-no-properties
             (region-beginning)
             (region-end))
          (let ((sym (thing-at-point 'symbol)))
            (when (stringp sym)
              (regexp-quote sym))))
        regexp-history)
  (call-interactively 'occur))
#+END_SRC

** visual-regexp

Two packages by the same author add visual cues to searching and/or
replacing with regular expressions:

- visual-regexp :: https://github.com/benma/visual-regexp.el
- visual-regexp-steroids :: https://github.com/benma/visual-regexp-steroids.el/

Installed using ELPA.

#+BEGIN_SRC elisp
(if (package-installed-p 'visual-regexp-steroids)
    (require 'visual-regexp-steroids))
#+END_SRC

** helm-swoop

Show matches to a search string in a another window.

A couple of nice touches:

- Use =M-i= to activate from within =isearch=
- While searching, =C-c C-e= activates edit-mode, in which you can
  edit the buffer from within the =helm-swoop= buffer

#+BEGIN_SRC elisp
(condition-case nil
    (require 'helm-swoop)
  (error (message "** could not activate helm-swoop")))
#+END_SRC

** Hydra for searching

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn
      (defhydra hydra-search (:color blue)
        "hydra-search"
        ("RET" helm-swoop "helm-swoop")
        ("b" helm-swoop-back-to-last-point "helm-swoop-back-to-last-point")
        ("f" file-file-in-project "find-file-in-project")
        ("m" helm-multi-swoop "helm-multi-swoop")
        ("M" helm-multi-swoop-all "helm-multi-swoop-all")
        ("o" occur "occur-dwim")
        ("O" occur-dwim "occur")
        ("r" vr/isearch-backward "vr/isearch-backward")
        ("s" vr/isearch-forward "vr/isearch-forward"))
      (global-set-key (kbd "C-c s") 'hydra-search/body))
  (message "** hydra is not installed"))
#+END_SRC

** Hydra for string replacement

#+BEGIN_SRC elisp
(if (require 'hydra nil 'noerror)
    (progn (defhydra hydra-replace (:color blue)
             "hydra-replace"
             ("RET" replace-string "replace-string")
             ("r" vr/replace "vr/replace")
             ("q" query-replace "query-replace")
             ("Q" vr/query-replace "vr/query-replace"))

           (global-set-key (kbd "C-c r") 'hydra-replace/body))
  (message "** hydra is not installed"))
#+END_SRC

* Misc utilities
** copy-buffer-file-name

#+BEGIN_SRC elisp
(defun copy-buffer-file-name ()
  "Add `buffer-file-name' to `kill-ring'"
  (interactive)
  (kill-new buffer-file-name t))
(make-alias 'copy-buffer-file-name)
#+END_SRC

** copy-and-comment

#+BEGIN_SRC elisp
(defun copy-and-comment ()
  "Comment active region and paste uncommented text on the
following line."
  (interactive)
  (kill-new
   (buffer-substring
    (region-beginning)
    (region-end)))
  (comment-region (region-beginning)
                  (region-end))
  (goto-char (region-end))
  (delete-blank-lines)
  (newline 2)
  (yank))

(global-set-key (kbd "M-C-;") 'copy-and-comment)
#+END_SRC

** unfill-paragraph

from http://defindit.com/readme_files/emacs_hints_tricks.html

#+BEGIN_SRC elisp
(defun unfill-paragraph ()
  (interactive)
  (let ((fill-column (point-max)))
  (fill-paragraph nil)))
(global-set-key (kbd "M-C-q") 'unfill-paragraph)
(make-alias 'unfill-paragraph)
#+END_SRC

** Copy region to other window

Adapted from http://emacs.stackexchange.com/questions/3743/how-to-move-region-to-other-window

#+BEGIN_SRC elisp
(defun copy-region-or-line-other-window ()
  "Copy selected text or current line to other window"
  (interactive)
  (progn (save-excursion
           (if (region-active-p)
               (copy-region-as-kill
                (region-beginning) (region-end))
             (copy-region-as-kill
              (line-beginning-position) (+ (line-end-position) 1)))
           (other-window 1)
           (yank))
         (other-window -1)))

(make-alias 'copy-region-or-line-other-window)
#+END_SRC

* elisp-format

Written by Andy Stewart and available on emacswiki: http://www.emacswiki.org/emacs/elisp-format.el

#+BEGIN_SRC elisp
(condition-case nil
    (require 'elisp-format)
  (error (message "** could not load elisp-format")))
#+END_SRC

* emacsclient

Buffers opened from command line don't create new frame

#+BEGIN_SRC elisp
(setq ns-pop-up-frames nil)
#+END_SRC

* lockstep

Lockstep is a package for pair programming in Emacs. See https://github.com/tjim/lockstep

Installation:

#+BEGIN_SRC sh :eval no
wget -N https://github.com/tjim/lockstep/archive/master.zip
unzip master.zip lockstep-master/lockstep.el
mv lockstep-master/lockstep.el .
rm -r lockstep-master master.zip
#+END_SRC

#+BEGIN_SRC elisp
(require 'lockstep)
#+END_SRC

To use, attach emacsclient to a running emacs server and evaluate =M-x lockstep=.
After this, a second user can do the same.

* discover.el

Introduced in [[https://www.masteringemacs.org/article/discoverel-discover-emacs-context-menus][this blog post]] by Mickey Petersen, =discover.el=
provides Magit-style contextual menus for =dired= (activate using
=?=), register keys in =C-x r=, and the Isearch keys in =M-s=. I do in
fact discover something every time I use it!

#+BEGIN_SRC elisp
(condition-case nil
    (progn
      (require 'discover)
      (global-discover-mode 1))
      (error (message "** could not activate discover")))
#+END_SRC

* enable "advanced" commands

Not sure why these are disabled by default.

#+BEGIN_SRC elisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

* custom-set-variables

Emacs modifies this statement if you use the interactive "customize"
function, so don't do that.

#+BEGIN_SRC elisp
(custom-set-variables
  '(safe-local-variable-values (quote ((toggle-read-only . t)))))
#+END_SRC

* License
#+BEGIN_SRC elisp
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+END_SRC
